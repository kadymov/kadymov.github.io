Продвинутые типы TypeScript

Этот вопрос касается использования продвинутых возможностей системы типов TypeScript для создания безопасного и масштабируемого кода, включая utility types, conditional types, mapped types и другие сложные конструкции.

Utility Types

Основные Utility Types
Pick выбирает определенные свойства из типа. Например, из интерфейса User с полями id, name, email, password и createdAt можно создать PublicUser тип, содержащий только id, name и email.

Omit работает противоположно Pick - исключает определенные свойства. Можно создать CreateUser тип, исключив id и createdAt из User интерфейса.

Partial делает все свойства типа опциональными. Это полезно для типов обновления, где не все поля обязательны.

Required делает все свойства обязательными, даже если они были опциональными в оригинальном типе.

Record создает тип с заданными ключами и значениями. Например, можно создать тип StatusMessages где ключи - это статусы pending, approved, rejected, а значения - строки с сообщениями.

Продвинутые Utility Types
Exclude исключает типы из union. Если есть union тип AllColors с red, green, blue, yellow, то Exclude может исключить yellow, оставив только red, green, blue.

Extract извлекает определенные типы из union. Из того же AllColors можно извлечь только red и yellow.

NonNullable исключает null и undefined из типа, оставляя только основной тип.

ReturnType получает тип возвращаемого значения функции. Полезно когда нужно знать что возвращает функция без прямого указания типа.

Parameters получает типы параметров функции в виде tuple. Если функция принимает string и Partial User, то Parameters вернет кортеж этих типов.

ConstructorParameters делает то же самое для параметров конструктора класса.

Conditional Types

Базовые Conditional Types
Conditional types используют синтаксис условного оператора для выбора типа. Можно создать тип IsString который возвращает true если тип расширяет string, иначе false.

Более сложные conditional types могут проверять несколько условий. ApiResponse тип может возвращать разные структуры в зависимости от входного типа: объект с message для строк, с code для чисел, с data для других типов.

При использовании с union типами conditional types работают дистрибутивно - применяются к каждому члену union отдельно.

Distributive Conditional Types
Distributive поведение означает, что conditional type применяется к каждому члену union типа отдельно. Тип Flatten может извлекать элементы из массивов, и при применении к union string array или number array вернет string или number.

Distributive поведение можно отключить, обернув проверяемый тип в tuple. Тогда conditional type будет применяться ко всему union как к единому типу.

Практический пример - создание типизированных обработчиков событий, где тип обработчика зависит от имени события.

Mapped Types

Базовые Mapped Types
Mapped types позволяют создавать новые типы, применяя трансформации к каждому свойству существующего типа.

Можно создать Readonly версию типа, добавив readonly ко всем свойствам. Или наоборот, Mutable тип, который убирает readonly модификаторы.

Optional тип добавляет знак вопроса ко всем свойствам, делая их опциональными. Required убирает опциональность.

Stringify изменяет типы всех значений на string, сохраняя структуру объекта.

Продвинутые Mapped Types
Mapped types можно комбинировать с условиями для сложной логики. NullableKeys может найти все ключи в типе, значения которых могут быть null.

Можно создавать getters и setters для всех свойств типа, используя template literal types для генерации имен методов. Например, свойство name становится getName и setName методами.

Key remapping позволяет изменять имена ключей при создании mapped type, что полезно для создания API с определенными соглашениями об именах.

Template Literal Types

Базовое использование
Template literal types позволяют создавать типы на основе строковых литералов с переменными частями. Greeting тип может принимать любую строку после Hello.

С union типами template literals создают все возможные комбинации. Color и Size union типы могут создать Variant тип со всеми комбинациями red-small, red-medium и так далее.

Полезно для типизации CSS свойств, где можно создать все возможные margin и padding свойства.

Продвинутые Template Literal Types
Можно создавать имена event listeners, добавляя on к началу и делая первую букву заглавной. click становится onClick, hover становится onHover.

Для API endpoints можно комбинировать HTTP методы и ресурсы, создавая все возможные комбинации GET /api/users, POST /api/posts и так далее.

BEM методология CSS может быть типизирована через template literals, создавая правильные имена элементов и модификаторов.

Infer Keyword

Базовое использование infer
Infer позволяет извлекать типы из других типов в conditional types. ArrayElement может извлечь тип элемента из массива, используя infer для захвата типа элемента.

PromiseValue извлекает тип значения из Promise. Если есть Promise string, то PromiseValue вернет string.

FirstParameter извлекает тип первого параметра функции, игнорируя остальные параметры.

Продвинутое использование infer
DeepPromiseValue может работать с вложенными Promise, рекурсивно извлекая финальный тип даже из Promise Promise Promise string.

FunctionArgs извлекает все типы параметров функции в виде tuple, что полезно для создания wrapper функций.

Tail создает тип, содержащий все элементы tuple кроме первого. Это основа для многих utility типов, работающих с кортежами.

Recursive Types

Простая рекурсия
Recursive types ссылаются сами на себя для создания вложенных структур. NestedObject может создавать бесконечно вложенные объекты одного типа.

JSON типы - классический пример рекурсии, где JSONValue может быть примитивом, объектом или массивом других JSONValue.

Продвинутая рекурсия
DeepReadonly рекурсивно применяет readonly ко всем вложенным объектам, создавая полностью неизменяемую структуру.

DeepPartial делает все свойства опциональными на любом уровне вложенности.

Можно создавать типы путей для вложенных объектов, генерируя строки типа "profile.personal.name" для доступа к глубоко вложенным свойствам.

Брендированные типы

Брендированные типы добавляют уникальные маркеры к примитивным типам для предотвращения случайного смешивания похожих типов.

UserId, PostId, SessionId - все это строки, но с разными брендами. Это предотвращает передачу UserId в функцию, ожидающую PostId.

Создаются функции-конструкторы для создания брендированных типов и функции, работающие только с определенными брендами.

Валидационные типы как Email и URL обеспечивают, что строка прошла валидацию перед использованием в функциях, требующих валидные данные.

Практические паттерны

Builder Pattern с типами
Можно создать типизированный builder pattern, где компилятор проверяет что все обязательные поля установлены перед вызовом build метода.

FluentUserBuilder требует установки name и email перед build, иначе TypeScript выдаст ошибку компиляции. Это обеспечивает корректность на этапе компиляции.

Type-safe event system
TypedEventEmitter использует mapped types для создания типобезопасной системы событий. Каждое событие имеет определенную структуру данных, и TypeScript проверяет соответствие при emit и on вызовах.

EventMap определяет все возможные события и их типы данных. Обработчики автоматически получают правильно типизированные данные, а emit проверяет что передаются корректные данные.

Best Practices

Используйте строгие типы - включайте strict режим в tsconfig.json для максимальной безопасности типов.

Избегайте any - используйте unknown для неизвестных типов или создавайте специфические типы.

Композиция типов - создавайте сложные типы из простых, используя union, intersection и utility types.

Брендированные типы - используйте для критически важных значений вроде ID, email, URL для предотвращения ошибок.

Readonly по умолчанию - делайте данные immutable где это возможно для предотвращения случайных изменений.

Type guards - используйте для runtime проверок типов когда TypeScript не может статически определить тип.

Рекомендации для собеседования

На Senior-уровне ожидается глубокое понимание системы типов TypeScript, опыт с conditional и mapped types, знание utility types и умение создавать свои, понимание брендированных типов и их применения, опыт с type-safe архитектурными паттернами.

Частые вопросы на собеседованиях:
Разница между interface и type?
Как работают conditional types?
Что такое mapped types и когда их использовать?
Как создать type-safe API?
Как типизировать сложные JavaScript паттерны?

Этот материал связан с темами типизации React контекста, типизации состояния и тестирования типизированного кода.
