# Модель выполнения JavaScript (TTS)

Вопрос: Объясните модель выполнения JavaScript: стек вызовов, очередь макро- и микрозадач, промисы и async/await. Как распределяются setTimeout(0), queueMicrotask, Promise.then, requestAnimationFrame? Какие есть типичные ловушки порядка вывода?

Модель выполнения JavaScript — это сложная система, включающая стек вызовов, event loop, и различные очереди задач. Понимание этой модели критично для написания предсказуемого асинхронного кода.

Архитектура выполнения включает основные компоненты:

Call Stack или стек вызовов - это место где выполняется синхронный код. Функции добавляются в стек при вызове и удаляются после завершения.

Web APIs - это асинхронные операции, такие как setTimeout, fetch, DOM события, которые выполняются в фоне браузера.

Task Queues или очереди задач включают Macrotasks, Microtasks и Animation frames.

Event Loop координирует выполнение между стеком и очередями.

Очереди задач:

Macrotasks или Task Queue включают setTimeout, setInterval, setImmediate в Node.js, операции ввода-вывода, рендеринг UI, и DOM события.

Microtasks или Job Queue включают Promise.then, catch и finally, queueMicrotask, MutationObserver, и process.nextTick в Node.js.

Важно понимать, что все Microtasks выполняются перед любой Macrotask.

Детальное распределение задач:

setTimeout с нулевой задержкой добавляется в Macrotask queue.

queueMicrotask добавляется напрямую в Microtask queue.

Promise.then также добавляется в Microtask queue.

process.nextTick в Node.js имеет более высокий приоритет чем другие microtasks.

requestAnimationFrame выполняется перед рендером, но после microtasks.

Event Loop алгоритм работает следующим образом:

Сначала выполняется одна задача из macrotask queue. Затем выполняются ВСЕ microtasks из microtask queue. После этого может происходить рендеринг, включая animation callbacks. Затем цикл повторяется.

Сложные сценарии:

Рекурсивные microtasks могут заблокировать event loop, так как они будут выполняться бесконечно, не давая возможности выполниться macrotasks.

Смешанные async/await и промисы требуют понимания того, что каждый await создает новый microtask.

Типичные ловушки:

В циклах все промисы выполняются перед любым setTimeout, независимо от порядка их создания.

Async функции в циклах могут вести себя неожиданно. forEach с async функциями не ждет выполнения каждой итерации.

Promise constructors ведут себя по-разному при обработке ошибок по сравнению со static методами.

Применение в React:

Race conditions в useEffect могут возникать при быстром изменении зависимостей. Решение - использование флага отмены.

Timing в React updates важно понимать для предсказуемого поведения компонентов.

Инструменты для отладки:

Performance API позволяет измерять время выполнения различных операций.

Chrome DevTools предоставляет инструменты для анализа производительности и порядка выполнения.

Практические рекомендации:

Для предотвращения блокировки UI разбивайте тяжелые операции на части с использованием setTimeout или других асинхронных методов.

Оптимизируйте порядок операций: сначала немедленный UI feedback синхронно, затем критические microtasks, затем некритические операции в macrotasks.

Советы для senior разработчиков:

Понимайте приоритеты: Microtasks имеют приоритет выше Animation frames, которые имеют приоритет выше Macrotasks.

Избегайте бесконечных microtasks, так как они блокируют рендеринг.

Используйте AbortController для отмены запросов.

Профилируйте асинхронный код с Performance API.

В React следите за race conditions в useEffect.

Разбивайте тяжелые операции на асинхронные части.

Тестируйте timing-зависимый код с mock timers.

Debugging техники включают создание wrapper функций для отслеживания порядка выполнения операций.

Связанные темы: Event Loop, Microtasks и Macrotasks, Promises, Async/Await и Generators, Конкурентный рендеринг React 18, useEffect и Side Effects.
