# Let, Const, Var: Scope и Hoisting (TTS)

Вопрос: Разница между let, const и var в JavaScript, и как это влияет на scope и hoisting?

В JavaScript существует три способа объявления переменных: var, let и const. Каждый имеет свои особенности в отношении области видимости и поднятия.

Основные различия:

Переменная var имеет функциональную или глобальную область видимости, поднимается с присвоением undefined, разрешает переобъявление и переприсваивание, не имеет Temporal Dead Zone.

Переменная let имеет блочную область видимости, поднимается но попадает в Temporal Dead Zone, запрещает переобъявление, разрешает переприсваивание, имеет Temporal Dead Zone.

Переменная const имеет блочную область видимости, поднимается но попадает в Temporal Dead Zone, запрещает переобъявление и переприсваивание, имеет Temporal Dead Zone.

Var - Function Scoped:

Переменные, объявленные с var, видны во всей функции, даже если объявлены внутри блока. Это называется функциональной областью видимости. При попытке обращения к переменной до ее объявления мы получим undefined, а не ошибку.

Let - Block Scoped:

Переменные, объявленные с let, видны только в том блоке, где они объявлены. Это блочная область видимости. При попытке обращения к переменной до ее объявления получим ReferenceError из-за Temporal Dead Zone.

Const - Block Scoped и Immutable Binding:

Переменные, объявленные с const, также имеют блочную область видимости, но их нельзя переприсваивать. Важно понимать, что для объектов и массивов сама структура данных может быть изменена, но нельзя присвоить новое значение переменной.

Hoisting в деталях:

Все объявления переменных и функций поднимаются в начало их области видимости. Но var инициализируется значением undefined, а let и const попадают в Temporal Dead Zone до своего объявления.

Функции, объявленные через function declaration, поднимаются полностью и могут быть вызваны до их объявления. Function expressions не поднимаются.

Проблемы с var в циклах:

Классическая проблема возникает при использовании var в циклах с асинхронными функциями. Все колбэки будут ссылаться на одну и ту же переменную, которая к моменту выполнения будет иметь финальное значение.

С let каждая итерация цикла создает новую привязку переменной, поэтому каждый колбэк захватывает свою копию.

Temporal Dead Zone:

Это период между началом области видимости и инициализацией переменной let или const. В это время обращение к переменной вызывает ReferenceError. TDZ существует для предотвращения использования переменных до их инициализации.

Применение в React:

В современном React рекомендуется использовать const для hooks, стабильных значений и функций. Let используется для переменных, которые могут изменяться в процессе выполнения. Var следует избегать в современном коде.

Block Scope в условиях:

Переменные let и const, объявленные внутри блоков if, switch или try-catch, видны только внутри этих блоков. Var "вытекает" из блоков и становится доступной во всей функции.

В switch statements нужно использовать фигурные скобки для создания отдельной области видимости для каждого case.

Глобальные переменные:

Переменные var, объявленные в глобальной области, становятся свойствами глобального объекта (window в браузере). Let и const создают глобальные переменные, но не создают свойства глобального объекта.

Лучшие практики:

Рекомендуемый порядок предпочтений: сначала const по умолчанию, затем let когда нужно переприсваивание, и избегать var в современном коде.

В циклах используйте const если не меняете переменную, let для счетчиков и итераторов.

В функциях используйте const для массивов и объектов, let для счетчиков и временных переменных.

ESLint правила:

Настройте ESLint с правилами no-var для запрета var, prefer-const для предпочтения const, no-undef для запрета неопределенных переменных.

Влияние на производительность:

Var может создавать неожиданные замыкания в циклах, что влияет на производительность. Let и const создают новые привязки, что может быть эффективнее в некоторых случаях.

Советы для senior разработчиков:

Всегда используйте const по умолчанию, переходите к let только при необходимости. Избегайте var в современном коде. Понимайте Temporal Dead Zone для отладки ошибок инициализации. В React отдавайте предпочтение const для hooks и обработчиков. Используйте блочную область видимости для создания изолированных зон. Помните о влиянии на производительность.

Связанные темы: Event Loop, Microtasks и Macrotasks, Garbage Collection и оптимизация памяти, TypeScript в React проектах.
