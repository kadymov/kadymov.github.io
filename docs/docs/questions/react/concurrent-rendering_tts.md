# Конкурентный рендеринг React 18 (TTS)

Вопрос: Как в React 18 работает конкурентный рендеринг? Зачем нужны useTransition и useDeferredValue, чем они отличаются? Что такое автоматическое батчинг-объединение, какие побочные эффекты в StrictMode в dev, и как избегать race conditions при загрузке данных?

React 18 представил конкурентный рендеринг — фундаментальное изменение в том, как React обрабатывает обновления. Это позволяет React прерывать, приостанавливать и возобновлять рендеринг для поддержания отзывчивости пользовательского интерфейса.

Основы конкурентного рендеринга:

В React 17 и ранее использовался блокирующий рендеринг, когда тяжелые операции блокировали main thread. React 18 вводит конкурентный рендеринг, который включается при использовании createRoot вместо ReactDOM.render.

Приоритеты обновлений разделяются на три уровня:

Высокий приоритет включает пользовательские взаимодействия типа click и input, обновления фокуса, и анимации. Эти операции выполняются синхронно.

Обычный приоритет включает загрузку данных и обновления списков. Эти операции могут быть прерваны для более приоритетных задач.

Низкий приоритет включает аналитику, логирование, и фоновые обновления. Эти операции выполняются когда нет более важных задач.

useTransition Hook:

useTransition позволяет пометить обновления состояния как переходы, которые могут быть прерваны более приоритетными обновлениями. Hook возвращает isPending флаг и функцию startTransition.

Основное применение useTransition - для тяжелых операций типа фильтрации больших списков или поиска. Пользовательский ввод остается отзывчивым, а результаты обновляются с задержкой.

useDeferredValue Hook:

useDeferredValue позволяет отложить обновление значения до тех пор, пока не завершатся более приоритетные обновления. Это полезно для производных значений, которые требуют тяжелых вычислений.

Основное отличие от useTransition в том, что useDeferredValue работает с значениями, а useTransition с обновлениями состояния.

Сравнение useTransition и useDeferredValue:

useTransition используется для обновлений состояния, когда вы вызываете setState внутри startTransition. Вы получаете isPending флаг для отображения загрузки.

useDeferredValue используется для значений, которые передаются в useMemo или другие вычисления. Вы можете сравнить исходное и отложенное значения для определения актуальности.

Автоматическое батчинг:

React 18 автоматически группирует обновления состояния в одно обновление для улучшения производительности.

В React 17 батчинг работал только в event handlers. Асинхронные операции типа setTimeout или Promise не батчились и вызывали множественные рендеры.

В React 18 батчинг работает автоматически везде - в event handlers, асинхронных операциях, промисах. Это значительно улучшает производительность.

Для отключения батчинга можно использовать flushSync, который принудительно вызывает синхронный рендер для каждого обновления.

StrictMode в разработке:

React 18 усилил StrictMode для выявления побочных эффектов в конкурентном режиме. StrictMode теперь намеренно вызывает двойной рендеринг компонентов и эффектов в development режиме.

Это помогает найти проблемы с побочными эффектами, которые могут проявиться в production при конкурентном рендеринге. Render функции должны быть чистыми, а effects должны правильно очищаться.

Race Conditions и их предотвращение:

Race conditions возникают когда асинхронные операции завершаются в неправильном порядке. Это особенно критично при быстрой смене параметров загрузки данных.

Решение первое - флаг отмены. Используйте переменную cancelled внутри useEffect, которая устанавливается в true в cleanup функции.

Решение второе - AbortController. Создавайте AbortController для каждого запроса и отменяйте его в cleanup функции useEffect.

Решение третье - custom hook. Создайте переиспользуемый hook для API вызовов, который автоматически обрабатывает отмену и race conditions.

Suspense для данных:

Suspense интегрируется с конкурентными возможностями и позволяет декларативно обрабатывать загрузку данных. Используйте библиотеки типа React Query или SWR с поддержкой Suspense.

Миграция на React 18:

Основное изменение - замена ReactDOM.render на createRoot. Это включает конкурентные возможности и автоматический батчинг.

Нужно обратить внимание на изменения в StrictMode и протестировать приложение на двойные вызовы эффектов.

Лучшие практики:

Используйте useTransition для неблокирующих обновлений UI типа фильтрации списков. Не используйте для критических операций типа отправки форм.

Используйте useDeferredValue для производных значений, которые требуют тяжелых вычислений. Не используйте для простых отображений.

Всегда обрабатывайте race conditions с помощью AbortController или флагов отмены.

Тестируйте в StrictMode для выявления проблем с побочными эффектами.

Не оборачивайте все операции в transitions - только действительно тяжелые.

Профилируйте производительность с React DevTools для измерения реального эффекта.

Советы для senior разработчиков:

Включайте конкурентные возможности постепенно, начиная с createRoot. Используйте useTransition для тяжелых обновлений UI. useDeferredValue применяйте для производных значений. Всегда обрабатывайте race conditions. Тестируйте в StrictMode. Не оборачивайте все в transitions. Профилируйте с React DevTools.

Связанные темы: useEffect и Side Effects, Reconciliation и Virtual DOM, Оптимизация ререндеров, Event Loop, Microtasks и Macrotasks.
